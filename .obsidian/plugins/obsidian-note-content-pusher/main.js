/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
__export(exports, {
  default: () => ListModified
});

// node_modules/monkey-around/mjs/index.js
function after(promise, cb) {
  return promise.then(cb, cb);
}
function serialize(asyncFunction) {
  let lastRun = Promise.resolve();
  function wrapper(...args) {
    return lastRun = new Promise((res, rej) => {
      after(lastRun, () => {
        asyncFunction.apply(this, args).then(res, rej);
      });
    });
  }
  wrapper.after = function() {
    return lastRun = new Promise((res, rej) => {
      after(lastRun, res);
    });
  };
  return wrapper;
}

// src/main.ts
var import_obsidian2 = __toModule(require("obsidian"));

// src/settings.ts
var import_obsidian = __toModule(require("obsidian"));
var DEFAULT_SETTINGS = {
  indicatorCharacter: ">>",
  inlineSettingCharacter: "@@",
  automaticPush: false,
  shouldPrepend: false
};
var ListModifiedSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings" });
    new import_obsidian.Setting(containerEl).setName("Content Pusher Character").setDesc("Specify the string of characters you want to use to indicate when you want to push content to a new note.").addText((text) => text.setPlaceholder(">>").setValue(this.plugin.settings.indicatorCharacter).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.indicatorCharacter = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Inline Settings Character").setDesc("Specify the string of characters you want to use within the curly brackts to customize how the content is pushed.").addText((text) => text.setPlaceholder("@@").setValue(this.plugin.settings.inlineSettingCharacter).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.inlineSettingCharacter = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Automatic Push").setDesc("Automatically push content to a new note, when your cursor moves to a new line (without you running a command).").addToggle((toggle) => toggle.setValue(this.plugin.settings.automaticPush).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.automaticPush = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Prepend to existing file").setDesc("If a file already exists, prepends the content to the existing file instead of putting it at the end.").addToggle((toggle) => toggle.setValue(this.plugin.settings.shouldPrepend).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.shouldPrepend = value;
      yield this.plugin.saveSettings();
    })));
  }
};

// src/main.ts
var ListModified = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.automaticPush = serialize((file, _data, cache) => __async(this, null, function* () {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
      if (view != null) {
        const indicatorCharacter = this.settings.indicatorCharacter;
        const editor = view.editor;
        const currentPos = editor.getCursor();
        const nextPos = { line: currentPos.line, ch: currentPos.ch + 1 };
        const zeroPos = { line: currentPos.line, ch: 0 };
        const lineString = editor.getRange(zeroPos, nextPos);
        if (this.settings.automaticPush == true && lineString.includes("]]" + indicatorCharacter + "{") == false) {
          yield this.createAndPush();
        }
      }
    }));
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.addCommand({
        id: "create-and-push",
        name: "Create file and push content",
        callback: () => this.createAndPush()
      });
      this.registerEvent(this.app.metadataCache.on("changed", this.automaticPush));
      this.addSettingTab(new ListModifiedSettingTab(this.app, this));
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  onunload() {
  }
  createAndPush() {
    return __async(this, null, function* () {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
      if (view != null) {
        const editor = view.editor;
        const editorText = editor.getValue();
        const indicatorCharacter = this.settings.indicatorCharacter;
        let newContent = "";
        let inlineSetting = "";
        let newTitle = "";
        let newAlias = "";
        let shouldPrepend = this.settings.shouldPrepend;
        try {
          newContent = editorText.split("]]" + indicatorCharacter + "{")[1].split("}")[0];
          if (newContent.includes(this.settings.inlineSettingCharacter)) {
            inlineSetting = newContent.split(this.settings.inlineSettingCharacter)[1];
            newContent = newContent.split(this.settings.inlineSettingCharacter)[0];
          }
          if (inlineSetting == "append") {
            shouldPrepend = false;
          } else if (inlineSetting == "prepend") {
            shouldPrepend = true;
          }
          const zeroPos = { line: 0, ch: 0 };
          const lastPos = { line: Number(editor.lineCount()) - 1, ch: editor.getLine(Number(editor.lineCount()) - 1).length };
          const tempSplit = editorText.split("]]" + indicatorCharacter + "{");
          const firstPart = tempSplit[0].split("[[");
          newTitle = firstPart[firstPart.length - 1];
          const restOfNote = tempSplit[1].split("}")[1];
          editor.replaceRange(tempSplit[0] + "]]" + restOfNote, zeroPos, lastPos);
          const newEditorText = tempSplit[0] + "]]" + restOfNote;
          if (newTitle.includes("|" + indicatorCharacter)) {
            newAlias = newTitle.split("|" + indicatorCharacter)[1];
            newTitle = newTitle.split("|" + indicatorCharacter)[0];
            editor.replaceRange(newEditorText.split("|" + indicatorCharacter)[0] + "|" + newEditorText.split("|" + indicatorCharacter)[1], zeroPos, lastPos);
          }
          const files = this.app.vault.getMarkdownFiles();
          let filesWithName = [];
          let baseTitleName = newTitle;
          if (baseTitleName.includes("/")) {
            let pathParts = baseTitleName.split("/");
            baseTitleName = pathParts[pathParts.length - 1];
          }
          let heading = "";
          if (newTitle.includes("#")) {
            heading = newTitle.split("#")[1];
            newTitle = newTitle.split("#")[0];
          }
          console.log("base: " + baseTitleName);
          for (let i = 0; i < files.length; i++) {
            if (files[i].basename == baseTitleName) {
              filesWithName.push(files[i]);
              break;
            }
          }
          let realExistingFile = null;
          if (filesWithName.length > 0) {
            if (filesWithName.length > 1) {
              for (let i = 0; i < filesWithName.length; i++) {
                if (filesWithName[i].path == newTitle + ".md") {
                  realExistingFile = filesWithName[i];
                  break;
                }
              }
            } else {
              realExistingFile = filesWithName[0];
            }
          }
          if (newAlias != "") {
            newAlias = newAlias + ", ";
          }
          if (filesWithName.length == 0) {
            new import_obsidian2.Notice(`Creating file and pushing content...`);
            if (newAlias == "") {
              yield this.app.vault.create(newTitle + ".md", newContent);
            } else {
              newContent = "---\nalias: " + newAlias + "\n---\n" + newContent;
              yield this.app.vault.create(newTitle + ".md", newContent);
            }
          } else {
            let pushingType = "Appending";
            if (shouldPrepend) {
              pushingType = "Prepending";
            }
            new import_obsidian2.Notice(`File already exists. ${pushingType} content...`);
            const fullExistingFileText = yield this.app.vault.read(realExistingFile);
            let newYaml = "";
            let existingFileText = "";
            if (fullExistingFileText.includes("---")) {
              console.log(fullExistingFileText.split("---"));
              if (fullExistingFileText.split("---").length > 2) {
                let currentYaml = fullExistingFileText.split("---")[1];
                for (let i = 2; i < fullExistingFileText.split("---").length; i++) {
                  if (i == 2) {
                    existingFileText = existingFileText + fullExistingFileText.split("---")[i];
                  } else {
                    existingFileText = existingFileText + fullExistingFileText.split("---")[i] + "---";
                  }
                }
                if (currentYaml.includes("alias:")) {
                  newYaml = "---" + currentYaml.split("alias:")[0] + "alias: " + newAlias + currentYaml.split("alias:")[1] + "---";
                } else {
                  newYaml = "---alias: " + newAlias + currentYaml + "---";
                }
              } else {
                newYaml = "---\nalias: " + newAlias + "\n---\n";
                existingFileText = fullExistingFileText;
              }
            } else {
              if (newAlias != "") {
                newYaml = "---\nalias: " + newAlias + "\n---\n";
              }
              existingFileText = fullExistingFileText;
            }
            ;
            if (heading == "") {
              if (shouldPrepend == true) {
                this.app.vault.modify(realExistingFile, newYaml + "\n" + newContent + "\n" + existingFileText);
              } else {
                this.app.vault.modify(realExistingFile, newYaml + existingFileText + "\n" + newContent);
              }
            } else {
              this.app.vault.modify(realExistingFile, newYaml + existingFileText.split("# " + heading)[0] + "\n# " + heading + "\n" + newContent + "\n" + existingFileText.split("# " + heading)[1]);
            }
          }
        } catch (err) {
          if (this.settings.automaticPush == false) {
            new import_obsidian2.Notice(`Didn't detect correct syntax. Doing nothing`);
          }
        }
      }
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiLCAibm9kZV9tb2R1bGVzL21vbmtleS1hcm91bmQvbWpzL2luZGV4LmpzIiwgInNyYy9zZXR0aW5ncy50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgc2VyaWFsaXplIH0gZnJvbSBcIm1vbmtleS1hcm91bmRcIjtcbmltcG9ydCB7XG5cdE1hcmtkb3duVmlldyxcblx0Q2FjaGVkTWV0YWRhdGEsXG5cdE5vdGljZSxcblx0UGx1Z2luLFxuXHRURmlsZSxcbn0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbmltcG9ydCB7XG5cdExpc3RNb2RpZmllZFNldHRpbmdzLFxuXHRERUZBVUxUX1NFVFRJTkdTLFxuXHRMaXN0TW9kaWZpZWRTZXR0aW5nVGFiLFxufSBmcm9tIFwiLi9zZXR0aW5nc1wiO1xuXG5cbi8vIGV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVBTm90ZShwYXRoOiBTdHJpbmcsIGNvbnRlbnQ6IFN0cmluZyk6IFByb21pc2U8VEZpbGU+IHtcbi8vIFx0Y29uc3QgYXBwID0gd2luZG93LmFwcCBhcyBBcHA7XG4vLyBcdGNvbnN0IHsgdmF1bHQgfSA9IGFwcDtcblxuLy8gXHR0cnkge1xuLy8gXHRcdGNvbnN0IGNyZWF0ZWRGaWxlID0gYXdhaXQgdmF1bHQuY3JlYXRlKHBhdGgrXCIubWRcIiwgY29udGVudCk7XG4vLyBcdFx0cmV0dXJuIGNyZWF0ZWRGaWxlO1xuLy8gXHR9IGNhdGNoIChlcnIpIHtcbi8vIFx0XHRuZXcgTm90aWNlKGBTb21ldGhpbmcgZGlkbid0IHdvcmsuYClcbi8vIFx0fVxuLy8gfVxuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpc3RNb2RpZmllZCBleHRlbmRzIFBsdWdpbiB7XG5cdHNldHRpbmdzOiBMaXN0TW9kaWZpZWRTZXR0aW5ncztcblxuXHRhc3luYyBvbmxvYWQoKSB7XG5cdFx0YXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiY3JlYXRlLWFuZC1wdXNoXCIsXG5cdFx0XHRuYW1lOiBcIkNyZWF0ZSBmaWxlIGFuZCBwdXNoIGNvbnRlbnRcIixcblx0XHRcdGNhbGxiYWNrOiAoKSA9PiB0aGlzLmNyZWF0ZUFuZFB1c2goKSxcblx0XHR9KTtcblxuXHRcdHRoaXMucmVnaXN0ZXJFdmVudChcblx0XHRcdHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUub24oXCJjaGFuZ2VkXCIsIHRoaXMuYXV0b21hdGljUHVzaClcblx0XHQpO1xuXG5cdFx0dGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBMaXN0TW9kaWZpZWRTZXR0aW5nVGFiKHRoaXMuYXBwLCB0aGlzKSk7XG5cdH1cblxuXHRhc3luYyBzYXZlU2V0dGluZ3MoKSB7XG5cdFx0YXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcblx0fVxuXG5cdG9udW5sb2FkKCkge31cblxuXHQvLyB0aGUgZmlyc3QgZnVuY3Rpb24gdGhhdCBydW5zXG5cdGFzeW5jIGNyZWF0ZUFuZFB1c2goKSB7XG5cdFx0Ly8gY29uc3QgYXBwID0gd2luZG93LmFwcCBhcyBBcHA7XG5cdFx0Y29uc3QgdmlldyA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVWaWV3T2ZUeXBlKE1hcmtkb3duVmlldyk7XG5cdFx0aWYgKHZpZXchPW51bGwpIHtcblx0XHRcdGNvbnN0IGVkaXRvciA9IHZpZXcuZWRpdG9yO1xuXHRcdFx0Y29uc3QgZWRpdG9yVGV4dCA9IGVkaXRvci5nZXRWYWx1ZSgpO1xuXHRcdFx0Y29uc3QgaW5kaWNhdG9yQ2hhcmFjdGVyID0gdGhpcy5zZXR0aW5ncy5pbmRpY2F0b3JDaGFyYWN0ZXJcblx0XHRcdGxldCBuZXdDb250ZW50ID0gXCJcIlxuXHRcdFx0bGV0IGlubGluZVNldHRpbmcgPSBcIlwiXG5cdFx0XHRsZXQgbmV3VGl0bGUgPSBcIlwiXG5cdFx0XHRsZXQgbmV3QWxpYXMgPSBcIlwiXG5cdFx0XHRsZXQgc2hvdWxkUHJlcGVuZCA9IHRoaXMuc2V0dGluZ3Muc2hvdWxkUHJlcGVuZFxuXG5cdFx0XHQvLyBjaGVjayBpZiBzeW50YXggdG8gcHVzaCBmaWxlIGlzIHByZXNlbnRcblx0XHRcdHRyeSB7XG5cdFx0XHRcdG5ld0NvbnRlbnQgPSBlZGl0b3JUZXh0LnNwbGl0KFwiXV1cIiArIGluZGljYXRvckNoYXJhY3RlciArIFwie1wiKVsxXS5zcGxpdChcIn1cIilbMF07XG5cdFx0XHRcdGlmIChuZXdDb250ZW50LmluY2x1ZGVzKHRoaXMuc2V0dGluZ3MuaW5saW5lU2V0dGluZ0NoYXJhY3RlcikpIHtcblx0XHRcdFx0XHRpbmxpbmVTZXR0aW5nID0gbmV3Q29udGVudC5zcGxpdCh0aGlzLnNldHRpbmdzLmlubGluZVNldHRpbmdDaGFyYWN0ZXIpWzFdO1xuXHRcdFx0XHRcdG5ld0NvbnRlbnQgPSBuZXdDb250ZW50LnNwbGl0KHRoaXMuc2V0dGluZ3MuaW5saW5lU2V0dGluZ0NoYXJhY3RlcilbMF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaW5saW5lU2V0dGluZyA9PSBcImFwcGVuZFwiKSB7XG5cdFx0XHRcdFx0c2hvdWxkUHJlcGVuZCA9IGZhbHNlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGlubGluZVNldHRpbmcgPT0gXCJwcmVwZW5kXCIpIHtcblx0XHRcdFx0XHRzaG91bGRQcmVwZW5kID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XG5cblx0XHRcdFx0Ly8gZml4IGZvcm1hdHRpbmcgb2Ygb3JpZ2luYWwgbm90ZVxuXHRcdFx0XHQvLyBjb25zdCB2aWV3ID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoTWFya2Rvd25WaWV3KTtcblx0XHRcdFx0Ly8gY29uc3QgZWRpdG9yID0gdmlldy5lZGl0b3I7XG5cdFx0XHRcdGNvbnN0IHplcm9Qb3MgPSB7IGxpbmU6IDAsIGNoOiAwIH07XG5cdFx0XHRcdGNvbnN0IGxhc3RQb3MgPSB7IGxpbmU6IE51bWJlcihlZGl0b3IubGluZUNvdW50KCkpIC0gMSwgY2g6IGVkaXRvci5nZXRMaW5lKE51bWJlcihlZGl0b3IubGluZUNvdW50KCkpIC0gMSkubGVuZ3RoIH07XG5cdFx0XHRcdGNvbnN0IHRlbXBTcGxpdCA9IGVkaXRvclRleHQuc3BsaXQoXCJdXVwiICsgaW5kaWNhdG9yQ2hhcmFjdGVyICsgXCJ7XCIpO1xuXHRcdFx0XHRjb25zdCBmaXJzdFBhcnQgPSB0ZW1wU3BsaXRbMF0uc3BsaXQoXCJbW1wiKTtcblx0XHRcdFx0bmV3VGl0bGUgPSBmaXJzdFBhcnRbZmlyc3RQYXJ0Lmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRjb25zdCByZXN0T2ZOb3RlID0gdGVtcFNwbGl0WzFdLnNwbGl0KFwifVwiKVsxXVxuXHRcdFx0XHQvLyB0aGlzLmFwcC52YXVsdC5tb2RpZnkodmlldy5maWxlLCB0ZW1wU3BsaXRbMF0gKyBcIl1dXCIgKyByZXN0T2ZOb3RlKVxuXHRcdFx0XHRlZGl0b3IucmVwbGFjZVJhbmdlKHRlbXBTcGxpdFswXSArIFwiXV1cIiArIHJlc3RPZk5vdGUsIHplcm9Qb3MsIGxhc3RQb3MpO1xuXHRcdFx0XHRjb25zdCBuZXdFZGl0b3JUZXh0ID0gdGVtcFNwbGl0WzBdICsgXCJdXVwiICsgcmVzdE9mTm90ZVxuXHRcdFx0XHRpZiAobmV3VGl0bGUuaW5jbHVkZXMoXCJ8XCIgKyBpbmRpY2F0b3JDaGFyYWN0ZXIpKSB7XG5cdFx0XHRcdFx0bmV3QWxpYXMgPSBuZXdUaXRsZS5zcGxpdChcInxcIiArIGluZGljYXRvckNoYXJhY3RlcilbMV1cblx0XHRcdFx0XHRuZXdUaXRsZSA9IG5ld1RpdGxlLnNwbGl0KFwifFwiICsgaW5kaWNhdG9yQ2hhcmFjdGVyKVswXVxuXHRcdFx0XHRcdGVkaXRvci5yZXBsYWNlUmFuZ2UobmV3RWRpdG9yVGV4dC5zcGxpdChcInxcIiArIGluZGljYXRvckNoYXJhY3RlcilbMF0gKyBcInxcIiArIG5ld0VkaXRvclRleHQuc3BsaXQoXCJ8XCIgKyBpbmRpY2F0b3JDaGFyYWN0ZXIpWzFdLCB6ZXJvUG9zLCBsYXN0UG9zKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNoZWNrIGlmIGZpbGUgZXhpc3RzIGFscmVhZHlcblx0XHRcdFx0Y29uc3QgZmlsZXMgPSB0aGlzLmFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCk7XG5cdFx0XHRcdGxldCBmaWxlc1dpdGhOYW1lOiBURmlsZVtdID0gW107XG5cdFx0XHRcdGxldCBiYXNlVGl0bGVOYW1lID0gbmV3VGl0bGU7XG5cdFx0XHRcdGlmIChiYXNlVGl0bGVOYW1lLmluY2x1ZGVzKFwiL1wiKSkge1xuXHRcdFx0XHRcdGxldCBwYXRoUGFydHMgPSBiYXNlVGl0bGVOYW1lLnNwbGl0KFwiL1wiKTtcblx0XHRcdFx0XHRiYXNlVGl0bGVOYW1lID0gcGF0aFBhcnRzW3BhdGhQYXJ0cy5sZW5ndGggLSAxXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsZXQgaGVhZGluZyA9IFwiXCI7XG5cdFx0XHRcdGlmIChuZXdUaXRsZS5pbmNsdWRlcyhcIiNcIikpIHtcblx0XHRcdFx0XHRoZWFkaW5nID0gbmV3VGl0bGUuc3BsaXQoXCIjXCIpWzFdO1xuXHRcdFx0XHRcdG5ld1RpdGxlID0gbmV3VGl0bGUuc3BsaXQoXCIjXCIpWzBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiYmFzZTogXCIgKyBiYXNlVGl0bGVOYW1lKVxuXHRcdFx0XHRmb3IgKGxldCBpPTA7IGk8ZmlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoZmlsZXNbaV0uYmFzZW5hbWUgPT0gYmFzZVRpdGxlTmFtZSkge1xuXHRcdFx0XHRcdFx0ZmlsZXNXaXRoTmFtZS5wdXNoKGZpbGVzW2ldKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBmaWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChteUZpbGU6IFRGaWxlKSB7XG5cdFx0XHRcdC8vIFx0aWYgKG15RmlsZS5iYXNlbmFtZSA9PSBiYXNlVGl0bGVOYW1lKSB7XG5cdFx0XHRcdC8vIFx0XHRmaWxlc1dpdGhOYW1lLnB1c2gobXlGaWxlKTtcblx0XHRcdFx0Ly8gXHRcdGNvbnNvbGUubG9nKG15RmlsZSk7XG5cdFx0XHRcdC8vIFx0fVxuXHRcdFx0XHQvLyB9KTtcblx0XHRcdFx0bGV0IHJlYWxFeGlzdGluZ0ZpbGU6IFRGaWxlID0gbnVsbDtcblx0XHRcdFx0aWYgKGZpbGVzV2l0aE5hbWUubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdGlmIChmaWxlc1dpdGhOYW1lLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZXNXaXRoTmFtZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRpZiAoZmlsZXNXaXRoTmFtZVtpXS5wYXRoID09IG5ld1RpdGxlICsgXCIubWRcIikge1xuXHRcdFx0XHRcdFx0XHRcdHJlYWxFeGlzdGluZ0ZpbGUgPSBmaWxlc1dpdGhOYW1lW2ldO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBmaWxlc1dpdGhOYW1lLmZvckVhY2goZnVuY3Rpb24gKG15RmlsZTogVEZpbGUpIHtcblx0XHRcdFx0XHRcdC8vIFx0aWYgKG15RmlsZS5wYXRoID09IG5ld1RpdGxlICsgXCIubWRcIikge1xuXHRcdFx0XHRcdFx0Ly8gXHRcdHJlYWxFeGlzdGluZ0ZpbGUgPSBteUZpbGU7XG5cdFx0XHRcdFx0XHQvLyBcdH1cblx0XHRcdFx0XHRcdC8vIH0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZWFsRXhpc3RpbmdGaWxlID0gZmlsZXNXaXRoTmFtZVswXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBhcHBlbmQgY29udGVudCBvciBjcmVhdGUgbmV3IGZpbGVcblx0XHRcdFx0aWYgKG5ld0FsaWFzICE9IFwiXCIpIHtcblx0XHRcdFx0XHRuZXdBbGlhcyA9IG5ld0FsaWFzK1wiLCBcIlxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChmaWxlc1dpdGhOYW1lLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgQ3JlYXRpbmcgZmlsZSBhbmQgcHVzaGluZyBjb250ZW50Li4uYCk7XG5cdFx0XHRcdFx0aWYgKG5ld0FsaWFzID09IFwiXCIpIHtcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZShuZXdUaXRsZSArIFwiLm1kXCIsIG5ld0NvbnRlbnQpO1xuXHRcdFx0XHRcdFx0Ly8gY3JlYXRlQU5vdGUobmV3VGl0bGUsIG5ld0NvbnRlbnQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRuZXdDb250ZW50ID0gXCItLS1cXG5hbGlhczogXCIgKyBuZXdBbGlhcyArIFwiXFxuLS0tXFxuXCIgKyBuZXdDb250ZW50O1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlKG5ld1RpdGxlICsgXCIubWRcIiwgbmV3Q29udGVudCk7XG5cdFx0XHRcdFx0XHQvLyBjcmVhdGVBTm90ZShuZXdUaXRsZSwgbmV3Q29udGVudCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxldCBwdXNoaW5nVHlwZSA9IFwiQXBwZW5kaW5nXCI7XG5cdFx0XHRcdFx0aWYgKHNob3VsZFByZXBlbmQpIHtcblx0XHRcdFx0XHRcdHB1c2hpbmdUeXBlID0gXCJQcmVwZW5kaW5nXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYEZpbGUgYWxyZWFkeSBleGlzdHMuICR7cHVzaGluZ1R5cGV9IGNvbnRlbnQuLi5gKTtcblx0XHRcdFx0XHRjb25zdCBmdWxsRXhpc3RpbmdGaWxlVGV4dCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQocmVhbEV4aXN0aW5nRmlsZSk7XG5cdFx0XHRcdFx0bGV0IG5ld1lhbWwgPSBcIlwiXG5cdFx0XHRcdFx0bGV0IGV4aXN0aW5nRmlsZVRleHQgPSBcIlwiXG5cdFx0XHRcdFx0aWYgKGZ1bGxFeGlzdGluZ0ZpbGVUZXh0LmluY2x1ZGVzKFwiLS0tXCIpKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhmdWxsRXhpc3RpbmdGaWxlVGV4dC5zcGxpdChcIi0tLVwiKSlcblx0XHRcdFx0XHRcdGlmIChmdWxsRXhpc3RpbmdGaWxlVGV4dC5zcGxpdChcIi0tLVwiKS5sZW5ndGggPiAyKSB7XG5cdFx0XHRcdFx0XHRcdGxldCBjdXJyZW50WWFtbCA9IGZ1bGxFeGlzdGluZ0ZpbGVUZXh0LnNwbGl0KFwiLS0tXCIpWzFdXG5cdFx0XHRcdFx0XHRcdGZvciAobGV0IGk9MjsgaTxmdWxsRXhpc3RpbmdGaWxlVGV4dC5zcGxpdChcIi0tLVwiKS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChpPT0yKXtcblx0XHRcdFx0XHRcdFx0XHRcdGV4aXN0aW5nRmlsZVRleHQgPSBleGlzdGluZ0ZpbGVUZXh0ICsgZnVsbEV4aXN0aW5nRmlsZVRleHQuc3BsaXQoXCItLS1cIilbaV1cblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXhpc3RpbmdGaWxlVGV4dCA9IGV4aXN0aW5nRmlsZVRleHQgKyBmdWxsRXhpc3RpbmdGaWxlVGV4dC5zcGxpdChcIi0tLVwiKVtpXSArIFwiLS0tXCJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKGN1cnJlbnRZYW1sLmluY2x1ZGVzKFwiYWxpYXM6XCIpKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmV3WWFtbCA9IFwiLS0tXCIgKyBjdXJyZW50WWFtbC5zcGxpdChcImFsaWFzOlwiKVswXSArIFwiYWxpYXM6IFwiICsgbmV3QWxpYXMgKyBjdXJyZW50WWFtbC5zcGxpdChcImFsaWFzOlwiKVsxXSArIFwiLS0tXCJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRuZXdZYW1sID0gXCItLS1hbGlhczogXCIgKyBuZXdBbGlhcyArIGN1cnJlbnRZYW1sICsgXCItLS1cIlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRuZXdZYW1sID0gXCItLS1cXG5hbGlhczogXCIgKyBuZXdBbGlhcyArIFwiXFxuLS0tXFxuXCI7XG5cdFx0XHRcdFx0XHRcdGV4aXN0aW5nRmlsZVRleHQgPSBmdWxsRXhpc3RpbmdGaWxlVGV4dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKG5ld0FsaWFzIT1cIlwiKSB7XG5cdFx0XHRcdFx0XHRcdG5ld1lhbWwgPSBcIi0tLVxcbmFsaWFzOiBcIiArIG5ld0FsaWFzICsgXCJcXG4tLS1cXG5cIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGV4aXN0aW5nRmlsZVRleHQgPSBmdWxsRXhpc3RpbmdGaWxlVGV4dDtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGlmIChoZWFkaW5nID09IFwiXCIpIHtcblx0XHRcdFx0XHRcdGlmIChzaG91bGRQcmVwZW5kID09IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5hcHAudmF1bHQubW9kaWZ5KHJlYWxFeGlzdGluZ0ZpbGUsIG5ld1lhbWwgKyBcIlxcblwiICsgbmV3Q29udGVudCArIFwiXFxuXCIgKyBleGlzdGluZ0ZpbGVUZXh0KVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5hcHAudmF1bHQubW9kaWZ5KHJlYWxFeGlzdGluZ0ZpbGUsIG5ld1lhbWwgKyBleGlzdGluZ0ZpbGVUZXh0ICsgXCJcXG5cIiArIG5ld0NvbnRlbnQpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuYXBwLnZhdWx0Lm1vZGlmeShyZWFsRXhpc3RpbmdGaWxlLCBuZXdZYW1sICsgZXhpc3RpbmdGaWxlVGV4dC5zcGxpdChcIiMgXCIgKyBoZWFkaW5nKVswXSArIFwiXFxuIyBcIiArIGhlYWRpbmcgKyBcIlxcblwiICsgbmV3Q29udGVudCArIFwiXFxuXCIgKyBleGlzdGluZ0ZpbGVUZXh0LnNwbGl0KFwiIyBcIiArIGhlYWRpbmcpWzFdKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0aWYgKHRoaXMuc2V0dGluZ3MuYXV0b21hdGljUHVzaCA9PSBmYWxzZSkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYERpZG4ndCBkZXRlY3QgY29ycmVjdCBzeW50YXguIERvaW5nIG5vdGhpbmdgKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhdXRvbWF0aWNQdXNoID0gc2VyaWFsaXplKFxuXHRcdGFzeW5jIChmaWxlOiBURmlsZSwgX2RhdGE6IHN0cmluZywgY2FjaGU6IENhY2hlZE1ldGFkYXRhKSA9PiB7XG5cdFx0XHRjb25zdCB2aWV3ID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoTWFya2Rvd25WaWV3KTtcblx0XHRcdGlmICh2aWV3IT0gbnVsbCkge1xuXHRcdFx0XHRjb25zdCBpbmRpY2F0b3JDaGFyYWN0ZXIgPSB0aGlzLnNldHRpbmdzLmluZGljYXRvckNoYXJhY3RlclxuXHRcdFx0XHRjb25zdCBlZGl0b3IgPSB2aWV3LmVkaXRvcjtcblx0XHRcdFx0Y29uc3QgY3VycmVudFBvcyA9IGVkaXRvci5nZXRDdXJzb3IoKTtcblx0XHRcdFx0Y29uc3QgbmV4dFBvcyA9IHsgbGluZTogY3VycmVudFBvcy5saW5lLCBjaDogY3VycmVudFBvcy5jaCArIDEgfTtcblx0XHRcdFx0Y29uc3QgemVyb1BvcyA9IHsgbGluZTogY3VycmVudFBvcy5saW5lLCBjaDogMCB9O1xuXHRcdFx0XHRjb25zdCBsaW5lU3RyaW5nID0gZWRpdG9yLmdldFJhbmdlKHplcm9Qb3MsIG5leHRQb3MpO1xuXHRcdFx0XHRpZiAodGhpcy5zZXR0aW5ncy5hdXRvbWF0aWNQdXNoID09IHRydWUgJiYgbGluZVN0cmluZy5pbmNsdWRlcyhcIl1dXCIgKyBpbmRpY2F0b3JDaGFyYWN0ZXIgKyBcIntcIikgPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLmNyZWF0ZUFuZFB1c2goKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0KTtcblxuXG5cdHByaXZhdGUgYXN5bmMgbG9hZFNldHRpbmdzKCkge1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKFxuXHRcdFx0e30sXG5cdFx0XHRERUZBVUxUX1NFVFRJTkdTLFxuXHRcdFx0YXdhaXQgdGhpcy5sb2FkRGF0YSgpXG5cdFx0KTtcblx0fVxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBhcm91bmQob2JqLCBmYWN0b3JpZXMpIHtcbiAgICBjb25zdCByZW1vdmVycyA9IE9iamVjdC5rZXlzKGZhY3RvcmllcykubWFwKGtleSA9PiBhcm91bmQxKG9iaiwga2V5LCBmYWN0b3JpZXNba2V5XSkpO1xuICAgIHJldHVybiByZW1vdmVycy5sZW5ndGggPT09IDEgPyByZW1vdmVyc1swXSA6IGZ1bmN0aW9uICgpIHsgcmVtb3ZlcnMuZm9yRWFjaChyID0+IHIoKSk7IH07XG59XG5mdW5jdGlvbiBhcm91bmQxKG9iaiwgbWV0aG9kLCBjcmVhdGVXcmFwcGVyKSB7XG4gICAgY29uc3Qgb3JpZ2luYWwgPSBvYmpbbWV0aG9kXSwgaGFkT3duID0gb2JqLmhhc093blByb3BlcnR5KG1ldGhvZCk7XG4gICAgbGV0IGN1cnJlbnQgPSBjcmVhdGVXcmFwcGVyKG9yaWdpbmFsKTtcbiAgICAvLyBMZXQgb3VyIHdyYXBwZXIgaW5oZXJpdCBzdGF0aWMgcHJvcHMgZnJvbSB0aGUgd3JhcHBpbmcgbWV0aG9kLFxuICAgIC8vIGFuZCB0aGUgd3JhcHBpbmcgbWV0aG9kLCBwcm9wcyBmcm9tIHRoZSBvcmlnaW5hbCBtZXRob2RcbiAgICBpZiAob3JpZ2luYWwpXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihjdXJyZW50LCBvcmlnaW5hbCk7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHdyYXBwZXIsIGN1cnJlbnQpO1xuICAgIG9ialttZXRob2RdID0gd3JhcHBlcjtcbiAgICAvLyBSZXR1cm4gYSBjYWxsYmFjayB0byBhbGxvdyBzYWZlIHJlbW92YWxcbiAgICByZXR1cm4gcmVtb3ZlO1xuICAgIGZ1bmN0aW9uIHdyYXBwZXIoLi4uYXJncykge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGJlZW4gZGVhY3RpdmF0ZWQgYW5kIGFyZSBubyBsb25nZXIgd3JhcHBlZCwgcmVtb3ZlIG91cnNlbHZlc1xuICAgICAgICBpZiAoY3VycmVudCA9PT0gb3JpZ2luYWwgJiYgb2JqW21ldGhvZF0gPT09IHdyYXBwZXIpXG4gICAgICAgICAgICByZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgLy8gSWYgbm8gb3RoZXIgcGF0Y2hlcywganVzdCBkbyBhIGRpcmVjdCByZW1vdmFsXG4gICAgICAgIGlmIChvYmpbbWV0aG9kXSA9PT0gd3JhcHBlcikge1xuICAgICAgICAgICAgaWYgKGhhZE93bilcbiAgICAgICAgICAgICAgICBvYmpbbWV0aG9kXSA9IG9yaWdpbmFsO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpbbWV0aG9kXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudCA9PT0gb3JpZ2luYWwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIEVsc2UgcGFzcyBmdXR1cmUgY2FsbHMgdGhyb3VnaCwgYW5kIHJlbW92ZSB3cmFwcGVyIGZyb20gdGhlIHByb3RvdHlwZSBjaGFpblxuICAgICAgICBjdXJyZW50ID0gb3JpZ2luYWw7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih3cmFwcGVyLCBvcmlnaW5hbCB8fCBGdW5jdGlvbik7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGRlZHVwZShrZXksIG9sZEZuLCBuZXdGbikge1xuICAgIGNoZWNrW2tleV0gPSBrZXk7XG4gICAgcmV0dXJuIGNoZWNrO1xuICAgIGZ1bmN0aW9uIGNoZWNrKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIChvbGRGbltrZXldID09PSBrZXkgPyBvbGRGbiA6IG5ld0ZuKS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYWZ0ZXIocHJvbWlzZSwgY2IpIHtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKGNiLCBjYik7XG59XG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplKGFzeW5jRnVuY3Rpb24pIHtcbiAgICBsZXQgbGFzdFJ1biA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIGZ1bmN0aW9uIHdyYXBwZXIoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gbGFzdFJ1biA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICAgICAgYWZ0ZXIobGFzdFJ1biwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGFzeW5jRnVuY3Rpb24uYXBwbHkodGhpcywgYXJncykudGhlbihyZXMsIHJlaik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHdyYXBwZXIuYWZ0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsYXN0UnVuID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7IGFmdGVyKGxhc3RSdW4sIHJlcyk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHdyYXBwZXI7XG59XG4iLCAiaW1wb3J0IHsgQXBwLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgTGlzdE1vZGlmaWVkIGZyb20gXCIuL21haW5cIjtcblxuZXhwb3J0IGludGVyZmFjZSBMaXN0TW9kaWZpZWRTZXR0aW5ncyB7XG5cdGluZGljYXRvckNoYXJhY3Rlcjogc3RyaW5nO1xuXHRpbmxpbmVTZXR0aW5nQ2hhcmFjdGVyOiBzdHJpbmc7XG5cdGF1dG9tYXRpY1B1c2g6IGJvb2xlYW47XG5cdHNob3VsZFByZXBlbmQ6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1NFVFRJTkdTOiBMaXN0TW9kaWZpZWRTZXR0aW5ncyA9IHtcblx0aW5kaWNhdG9yQ2hhcmFjdGVyOiBcIj4+XCIsXG5cdGlubGluZVNldHRpbmdDaGFyYWN0ZXI6IFwiQEBcIixcblx0YXV0b21hdGljUHVzaDogZmFsc2UsXG5cdHNob3VsZFByZXBlbmQ6IGZhbHNlLFxufTtcblxuZXhwb3J0IGNsYXNzIExpc3RNb2RpZmllZFNldHRpbmdUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcblx0cGx1Z2luOiBMaXN0TW9kaWZpZWQ7XG5cdHRhZ1N0cmluZzogc3RyaW5nO1xuXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IExpc3RNb2RpZmllZCkge1xuXHRcdHN1cGVyKGFwcCwgcGx1Z2luKTtcblx0XHR0aGlzLnBsdWdpbiA9IHBsdWdpbjtcblx0fVxuXG5cdGRpc3BsYXkoKTogdm9pZCB7XG5cdFx0Y29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcblxuXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cblx0XHRjb250YWluZXJFbC5jcmVhdGVFbChcImgyXCIsIHsgdGV4dDogXCJTZXR0aW5nc1wiIH0pO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZShcIkNvbnRlbnQgUHVzaGVyIENoYXJhY3RlclwiKVxuXHRcdFx0LnNldERlc2MoXG5cdFx0XHRcdFwiU3BlY2lmeSB0aGUgc3RyaW5nIG9mIGNoYXJhY3RlcnMgeW91IHdhbnQgdG8gdXNlIHRvIGluZGljYXRlIHdoZW4geW91IHdhbnQgdG8gcHVzaCBjb250ZW50IHRvIGEgbmV3IG5vdGUuXCJcblx0XHRcdClcblx0XHRcdC5hZGRUZXh0KCh0ZXh0KSA9PlxuXHRcdFx0XHR0ZXh0XG5cdFx0XHRcdFx0LnNldFBsYWNlaG9sZGVyKFwiPj5cIilcblx0XHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuaW5kaWNhdG9yQ2hhcmFjdGVyKVxuXHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLmluZGljYXRvckNoYXJhY3RlciA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdCk7XG5cblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKFwiSW5saW5lIFNldHRpbmdzIENoYXJhY3RlclwiKVxuXHRcdFx0LnNldERlc2MoXG5cdFx0XHRcdFwiU3BlY2lmeSB0aGUgc3RyaW5nIG9mIGNoYXJhY3RlcnMgeW91IHdhbnQgdG8gdXNlIHdpdGhpbiB0aGUgY3VybHkgYnJhY2t0cyB0byBjdXN0b21pemUgaG93IHRoZSBjb250ZW50IGlzIHB1c2hlZC5cIlxuXHRcdFx0KVxuXHRcdFx0LmFkZFRleHQoKHRleHQpID0+XG5cdFx0XHRcdHRleHRcblx0XHRcdFx0XHQuc2V0UGxhY2Vob2xkZXIoXCJAQFwiKVxuXHRcdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5pbmxpbmVTZXR0aW5nQ2hhcmFjdGVyKVxuXHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLmlubGluZVNldHRpbmdDaGFyYWN0ZXIgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHQpO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZShcIkF1dG9tYXRpYyBQdXNoXCIpXG5cdFx0XHQuc2V0RGVzYyhcIkF1dG9tYXRpY2FsbHkgcHVzaCBjb250ZW50IHRvIGEgbmV3IG5vdGUsIHdoZW4geW91ciBjdXJzb3IgbW92ZXMgdG8gYSBuZXcgbGluZSAod2l0aG91dCB5b3UgcnVubmluZyBhIGNvbW1hbmQpLlwiKVxuXHRcdFx0LmFkZFRvZ2dsZSgodG9nZ2xlKSA9PlxuXHRcdFx0XHR0b2dnbGVcblx0XHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuYXV0b21hdGljUHVzaClcblx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5hdXRvbWF0aWNQdXNoID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0KTtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoXCJQcmVwZW5kIHRvIGV4aXN0aW5nIGZpbGVcIilcblx0XHRcdC5zZXREZXNjKFwiSWYgYSBmaWxlIGFscmVhZHkgZXhpc3RzLCBwcmVwZW5kcyB0aGUgY29udGVudCB0byB0aGUgZXhpc3RpbmcgZmlsZSBpbnN0ZWFkIG9mIHB1dHRpbmcgaXQgYXQgdGhlIGVuZC5cIilcblx0XHRcdC5hZGRUb2dnbGUoKHRvZ2dsZSkgPT5cblx0XHRcdFx0dG9nZ2xlXG5cdFx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnNob3VsZFByZXBlbmQpXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3Muc2hvdWxkUHJlcGVuZCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdCk7XG5cblx0XHQvLyBuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHQvLyBcdC5zZXROYW1lKFwi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
